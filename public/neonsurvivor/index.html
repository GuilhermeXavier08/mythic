<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Survivor - Rebalanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --bg-color: #050510;
            --text-color: #e0e0ff;
            --accent-color: #00f3ff;
            --danger-color: #ff0055;
            --gold-color: #ffd700;
            --glass-bg: rgba(20, 20, 40, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        /* UI OVERLAYS */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD TOP */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            text-shadow: 0 0 10px currentColor;
        }

        .stat-box {
            background: var(--glass-bg);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            pointer-events: auto;
        }

        .wave-counter {
            font-size: 2rem;
            font-weight: 900;
            color: var(--accent-color);
        }

        .money-counter {
            color: var(--gold-color);
        }

        .hp-bar-container {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
        }

        .hp-bar-fill {
            height: 100%;
            background: var(--danger-color);
            width: 100%;
            transition: width 0.2s;
            box-shadow: 0 0 10px var(--danger-color);
        }

        /* MENUS */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .panel {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid var(--accent-color);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px var(--accent-color);
            max-width: 800px;
            width: 90%;
        }

        h1 { margin: 0 0 20px 0; font-size: 3rem; color: var(--accent-color); text-transform: uppercase; letter-spacing: 5px; }
        h2 { color: #fff; margin-bottom: 30px; }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .class-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .class-card:hover, .class-card.selected {
            background: var(--accent-color);
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent-color);
        }

        .class-icon { font-size: 2rem; margin-bottom: 10px; display: block; }
        .class-name { font-weight: bold; display: block; }
        .class-desc { font-size: 0.8rem; opacity: 0.8; margin-top: 5px; display: block; }

        button.btn-primary {
            background: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            font-weight: bold;
        }

        button.btn-primary:hover {
            background: var(--accent-color);
            color: #000;
            box-shadow: 0 0 30px var(--accent-color);
        }

        /* SHOP / UPGRADE MENU */
        #shopMenu { display: none; }
        .shop-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px; }
        .shop-item { background: #222; padding: 20px; border-radius: 10px; cursor: pointer; border: 1px solid #444; }
        .shop-item:hover { border-color: var(--gold-color); }
        .shop-cost { color: var(--gold-color); font-weight: bold; }

        /* NOTIFICATIONS */
        #notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #autoStartTimer {
            font-size: 1.5rem;
            color: #aaa;
            margin-top: 15px;
        }
    </style>
</head>
<body>

    <!-- GAME CANVAS -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div class="ui-layer" id="gameUI" style="display: none;">
        <div class="hud-top">
            <div class="stat-box">
                HP <div class="hp-bar-container"><div id="hpBar" class="hp-bar-fill"></div></div>
            </div>
            <div class="wave-counter">TURNO: <span id="waveNum">1</span></div>
            <div class="stat-box money-counter">
                $ <span id="moneyNum">0</span>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            <div id="ammoDisplay" style="font-size: 0.9rem; opacity: 0.7;">Muni√ß√£o Infinita (Cooldown)</div>
        </div>
    </div>

    <!-- START MENU -->
    <div id="startMenu" class="menu-overlay">
        <div class="panel">
            <h1>NEON SURVIVOR</h1>
            <h2>Escolha sua Classe</h2>
            <div class="class-grid">
                <div class="class-card selected" onclick="selectClass('pistoleiro', this)">
                    <span class="class-icon">üî´</span>
                    <span class="class-name">Pistoleiro</span>
                    <span class="class-desc">R√°pido. Cad√™ncia alta. Equilibrado.</span>
                </div>
                <div class="class-card" onclick="selectClass('shotgun', this)">
                    <span class="class-icon">üí•</span>
                    <span class="class-name">Shotgun</span>
                    <span class="class-desc">Curto alcance. 5 Balas. Dano Brutal.</span>
                </div>
                <div class="class-card" onclick="selectClass('guerreiro', this)">
                    <span class="class-icon">‚öîÔ∏è</span>
                    <span class="class-name">Guerreiro</span>
                    <span class="class-desc">Tanque. Ataque Melee r√°pido.</span>
                </div>
                <div class="class-card" onclick="selectClass('sniper', this)">
                    <span class="class-icon">üéØ</span>
                    <span class="class-name">Sniper</span>
                    <span class="class-desc">Longo alcance. Perfurante. Muito Lento.</span>
                </div>
                <div class="class-card" onclick="selectClass('bazuca', this)">
                    <span class="class-icon">üöÄ</span>
                    <span class="class-name">Bazuca</span>
                    <span class="class-desc">Explosivo em √°rea. Recarga lenta.</span>
                </div>
            </div>
            <button class="btn-primary" onclick="startGame()">INICIAR MISS√ÉO</button>
        </div>
    </div>

    <!-- SHOP / INTERMISSION MENU -->
    <div id="shopMenu" class="menu-overlay">
        <div class="panel">
            <h1 style="font-size: 2rem;">MERCADO DE COMBATE</h1>
            <p>Prepare-se para o Turno <span id="nextWaveNum">2</span></p>
            
            <div class="shop-grid">
                <div class="shop-item" onclick="buyUpgrade('damage')">
                    <h3>Dano +10%</h3>
                    <p class="shop-cost">$<span id="costDamage">100</span></p>
                </div>
                <div class="shop-item" onclick="buyUpgrade('speed')">
                    <h3>Velocidade +5%</h3>
                    <p class="shop-cost">$<span id="costSpeed">80</span></p>
                </div>
                <div class="shop-item" onclick="buyUpgrade('health')">
                    <h3>Curar 50 HP</h3>
                    <p class="shop-cost">$<span id="costHealth">50</span></p>
                </div>
                <div class="shop-item" onclick="buyUpgrade('firerate')">
                    <h3>Recarga -5%</h3>
                    <p class="shop-cost">$<span id="costFire">150</span></p>
                </div>
            </div>

            <div id="autoStartTimer">Pr√≥ximo turno em: 5s</div>
            <br>
            <button class="btn-primary" onclick="nextWave()">IR AGORA</button>
        </div>
    </div>

    <!-- GAME OVER MENU -->
    <div id="gameOverMenu" class="menu-overlay" style="display: none;">
        <div class="panel">
            <h1 style="color: var(--danger-color);">MISS√ÉO FALHOU</h1>
            <h2>Voc√™ sobreviveu at√© o Turno <span id="finalWave">0</span></h2>
            <button class="btn-primary" onclick="location.reload()">REINICIAR</button>
        </div>
    </div>

    <div id="notification">TURNO 1</div>

    <script>
        /**
         * ENGINE & CONFIG
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game State
        const Game = {
            state: 'MENU', // MENU, PLAY, SHOP, GAMEOVER
            wave: 1,
            money: 0,
            enemies: [],
            projectiles: [],
            particles: [],
            texts: [], // Floating combat text
            lastTime: 0,
            autoStartInterval: null,
            cameraShake: 0
        };

        // Inputs
        const Input = {
            keys: {},
            mouse: { x: 0, y: 0, down: false }
        };

        window.addEventListener('keydown', e => Input.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => Input.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { Input.mouse.x = e.clientX; Input.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => Input.mouse.down = true);
        window.addEventListener('mouseup', () => Input.mouse.down = false);

        /**
         * CLASSES DEFINITIONS & BALANCE
         */
        const CLASSES = {
            pistoleiro: {
                name: 'Pistoleiro',
                hp: 100,
                speed: 4,
                damage: 25, // Buffed
                fireRate: 200, // ms (Buffed: very fast)
                range: 600,
                color: '#00f3ff',
                type: 'bullet',
                spread: 0.1
            },
            shotgun: {
                name: 'Shotgun',
                hp: 120,
                speed: 3.5,
                damage: 18, // Per pellet (Buffed)
                fireRate: 900, // ms
                range: 350,
                color: '#ffaa00',
                type: 'shotgun',
                count: 5, // Buffed from 3
                spread: 0.5
            },
            guerreiro: {
                name: 'Guerreiro',
                hp: 200,
                speed: 4.5,
                damage: 40,
                fireRate: 400, // Swing speed
                range: 80, // Melee range
                color: '#ff0055',
                type: 'melee'
            },
            sniper: {
                name: 'Sniper',
                hp: 80,
                speed: 3.5,
                damage: 250, // Massive damage
                fireRate: 2000, // Nerfed: Very slow
                range: 1200,
                color: '#00ff00',
                type: 'piercing',
                velocity: 25
            },
            bazuca: {
                name: 'Bazuca',
                hp: 100,
                speed: 3,
                damage: 80, // Area damage
                fireRate: 2500, // Nerfed: Very slow
                range: 800,
                color: '#ff5500',
                type: 'rocket',
                radius: 120 // Explosion radius
            }
        };

        let selectedClass = 'pistoleiro';
        
        // Upgrades Costs
        const COSTS = { damage: 100, speed: 80, health: 50, firerate: 150 };
        const MULTIPLIERS = { damage: 1.1, speed: 1.05, firerate: 0.95 };

        /**
         * ENTITIES
         */
        class Player {
            constructor(roleKey) {
                const role = CLASSES[roleKey];
                this.role = roleKey;
                this.x = width / 2;
                this.y = height / 2;
                this.radius = 15;
                
                // Stats
                this.maxHp = role.hp;
                this.hp = role.hp;
                this.speed = role.speed;
                this.baseDamage = role.damage;
                this.baseFireRate = role.fireRate;
                this.color = role.color;
                
                this.lastShot = 0;
                this.angle = 0;
                
                // Upgrade Multipliers
                this.dmgMult = 1;
                this.speedMult = 1;
                this.fireRateMult = 1;
            }

            get damage() { return this.baseDamage * this.dmgMult; }
            get fireRate() { return this.baseFireRate * this.fireRateMult; }
            get currentSpeed() { return this.speed * this.speedMult; }

            update(dt) {
                // Movement
                let dx = 0, dy = 0;
                if (Input.keys['w']) dy -= 1;
                if (Input.keys['s']) dy += 1;
                if (Input.keys['a']) dx -= 1;
                if (Input.keys['d']) dx += 1;

                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    this.x += (dx/len) * this.currentSpeed;
                    this.y += (dy/len) * this.currentSpeed;
                }

                // Bounds
                this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));

                // Aim
                this.angle = Math.atan2(Input.mouse.y - this.y, Input.mouse.x - this.x);

                // Shoot
                if (Input.mouse.down) {
                    const now = Date.now();
                    if (now - this.lastShot > this.fireRate) {
                        this.shoot();
                        this.lastShot = now;
                    }
                }
            }

            shoot() {
                const stats = CLASSES[this.role];
                const muzzleX = this.x + Math.cos(this.angle) * 20;
                const muzzleY = this.y + Math.sin(this.angle) * 20;

                // Screen shake small on shoot
                if(this.role === 'bazuca' || this.role === 'sniper') Game.cameraShake = 5;

                if (stats.type === 'melee') {
                    // Melee Swing
                    createProjectile(this.x, this.y, this.angle, 'melee', this.damage);
                } 
                else if (stats.type === 'shotgun') {
                    // Spread shot
                    for(let i=0; i<stats.count; i++) {
                        // Calculate spread angle centering the shot
                        const spreadAngle = this.angle - (stats.spread/2) + (Math.random() * stats.spread);
                        createProjectile(muzzleX, muzzleY, spreadAngle, 'bullet', this.damage);
                    }
                } 
                else if (stats.type === 'rocket') {
                    createProjectile(muzzleX, muzzleY, this.angle, 'rocket', this.damage);
                } 
                else if (stats.type === 'piercing') {
                    createProjectile(muzzleX, muzzleY, this.angle, 'sniper', this.damage);
                } 
                else {
                    // Standard Bullet with slight random spread for realism
                    const spread = (Math.random() - 0.5) * (stats.spread || 0.05);
                    createProjectile(muzzleX, muzzleY, this.angle + spread, 'bullet', this.damage);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Body glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;

                // Character Shape
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Weapon
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, -5, 25, 10);

                ctx.restore();
            }
        }

        class Enemy {
            constructor(isBoss) {
                // Spawn edge
                if (Math.random() < 0.5) {
                    this.x = Math.random() < 0.5 ? -30 : width + 30;
                    this.y = Math.random() * height;
                } else {
                    this.x = Math.random() * width;
                    this.y = Math.random() < 0.5 ? -30 : height + 30;
                }

                this.isBoss = isBoss;
                
                // Balance: HP Scaling
                // Bosses: Base 500 + 200 per wave (Hard but linear)
                // Normal: Base 20 + 10 per wave
                if (isBoss) {
                    this.maxHp = 500 + (Game.wave * 150);
                    this.radius = 40;
                    this.speed = 1.5; // Slower
                    this.color = '#ff0000';
                    this.moneyValue = 300;
                } else {
                    this.maxHp = 20 + (Game.wave * 10);
                    this.radius = 15;
                    this.speed = 2 + (Math.random());
                    this.color = '#aa00ff';
                    this.moneyValue = 15;
                }
                this.hp = this.maxHp;
            }

            update() {
                // Tracking
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                // Collision with Player
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.radius + player.radius) {
                    player.hp -= 0.5; // Continuous contact damage
                    updateHUD();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // HP Bar
                const hpPct = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(-this.radius, -this.radius - 10, this.radius*2, 5);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-this.radius, -this.radius - 10, this.radius*2 * hpPct, 5);

                // Body
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                if(this.isBoss) {
                    // Boss Shape (Spiky)
                    ctx.beginPath();
                    for(let i=0; i<5; i++) {
                        ctx.rotate(Math.PI*2/5);
                        ctx.lineTo(0, -this.radius);
                        ctx.lineTo(10, -this.radius/2);
                    }
                    ctx.fill();
                } else {
                    // Normal Shape (Square-ish)
                    ctx.beginPath();
                    ctx.rect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            takeDamage(amt) {
                this.hp -= amt;
                spawnFloatingText(amt.toFixed(0), this.x, this.y - 20, '#fff');
                
                // Flash effect
                spawnParticles(this.x, this.y, this.color, 2);

                if (this.hp <= 0) {
                    // FIX: Give money on kill
                    Game.money += this.moneyValue;
                    spawnFloatingText("+$"+this.moneyValue, this.x, this.y - 40, 'gold');
                    spawnParticles(this.x, this.y, this.color, 10);
                    
                    if(this.isBoss) {
                        Game.cameraShake = 20; // Big shake on boss death
                        spawnParticles(this.x, this.y, '#fff', 50);
                    }

                    updateHUD();
                    return true; // Dead
                }
                return false;
            }
        }

        class Projectile {
            constructor(x, y, angle, type, damage) {
                this.x = x;
                this.y = y;
                this.dx = Math.cos(angle);
                this.dy = Math.sin(angle);
                this.type = type;
                this.damage = damage;
                this.markedForDeletion = false;

                if (type === 'rocket') {
                    this.speed = 8;
                    this.radius = 8;
                    this.color = '#ff5500';
                    this.life = 100; // Time to live
                } else if (type === 'sniper') {
                    this.speed = 25; // Very fast
                    this.radius = 3;
                    this.color = '#00ff00';
                    this.life = 50;
                    this.pierce = 5; // Hits 5 enemies
                } else if (type === 'melee') {
                    this.speed = 0;
                    this.life = 5; // Short duration
                    this.radius = 60; // Big swing area
                    this.x = player.x + Math.cos(angle) * 40; // Offset
                    this.y = player.y + Math.sin(angle) * 40;
                } else {
                    // Bullet / Shotgun
                    this.speed = 12;
                    this.radius = 4;
                    this.color = '#ffff00';
                    this.life = 60;
                }
            }

            update() {
                if(this.type !== 'melee') {
                    this.x += this.dx * this.speed;
                    this.y += this.dy * this.speed;
                }
                this.life--;
                
                // Trail particle
                if(this.type === 'rocket' || this.type === 'sniper') {
                    if(Math.random() > 0.5) spawnParticles(this.x, this.y, this.color, 1);
                }

                if (this.life <= 0 || 
                    (this.x < 0 || this.x > width || this.y < 0 || this.y > height)) {
                    this.markedForDeletion = true;
                    // Explode rocket at end of range
                    if(this.type === 'rocket') explode(this.x, this.y, this.damage);
                }
            }

            draw() {
                if(this.type === 'melee') {
                    // Draw Swing
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath();
                    ctx.arc(0,0, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 3;
                this.dx = Math.cos(a) * s;
                this.dy = Math.sin(a) * s;
                this.life = 1.0;
                this.decay = 0.03 + Math.random() * 0.03;
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 1.0;
                this.dy = -1;
            }
            update() {
                this.y += this.dy;
                this.life -= 0.02;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 16px Orbitron';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        /**
         * GLOBAL FUNCTIONS
         */
        let player;

        function selectClass(role, el) {
            document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            selectedClass = role;
        }

        function startGame() {
            player = new Player(selectedClass);
            Game.wave = 1;
            Game.money = 0;
            Game.enemies = [];
            Game.projectiles = [];
            Game.particles = [];
            Game.texts = [];
            
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'flex';
            Game.state = 'PLAY';
            
            updateHUD();
            startWave();
            loop();
        }

        function startWave() {
            showNotification(`TURNO ${Game.wave}`);
            
            // Spawn Enemies
            let count = 5 + Math.floor(Game.wave * 1.5);
            let bossCount = Game.wave % 5 === 0 ? 1 : 0; // Boss every 5 waves

            const spawner = setInterval(() => {
                if (Game.state !== 'PLAY') { clearInterval(spawner); return; }
                
                if (count > 0) {
                    Game.enemies.push(new Enemy(false));
                    count--;
                } else if (bossCount > 0) {
                    Game.enemies.push(new Enemy(true));
                    bossCount--;
                    showNotification("BOSS WARNING!");
                    Game.cameraShake = 10;
                } else {
                    clearInterval(spawner);
                }
            }, 800); // Enemy spawn rate
        }

        function createProjectile(x, y, angle, type, damage) {
            Game.projectiles.push(new Projectile(x, y, angle, type, damage));
        }

        function spawnParticles(x, y, color, count) {
            for(let i=0; i<count; i++) Game.particles.push(new Particle(x, y, color));
        }

        function spawnFloatingText(text, x, y, color) {
            Game.texts.push(new FloatingText(text, x, y, color));
        }

        function explode(x, y, damage) {
            Game.cameraShake = 10;
            spawnParticles(x, y, '#ff5500', 20);
            
            // Draw explosion circle
            ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, 120, 0, Math.PI*2);
            ctx.fill();

            Game.enemies.forEach(e => {
                const dist = Math.hypot(e.x - x, e.y - y);
                if (dist < 120) {
                    if(e.takeDamage(damage)) {
                        // Killed by explosion
                    }
                }
            });
        }

        function checkCollisions() {
            // Projectile vs Enemy
            for (let i = Game.projectiles.length - 1; i >= 0; i--) {
                const p = Game.projectiles[i];
                let hit = false;

                for (let j = Game.enemies.length - 1; j >= 0; j--) {
                    const e = Game.enemies[j];
                    const dist = Math.hypot(p.x - e.x, p.y - e.y);
                    
                    if (dist < p.radius + e.radius) {
                        // HIT
                        const dead = e.takeDamage(p.damage);
                        if (dead) Game.enemies.splice(j, 1);
                        
                        if (p.type === 'rocket') {
                            explode(p.x, p.y, p.damage);
                            p.markedForDeletion = true;
                            hit = true;
                            break; 
                        } else if (p.type === 'sniper') {
                            // Pierce logic
                            spawnParticles(p.x, p.y, '#0f0', 3);
                            if(p.pierce > 0) {
                                p.pierce--;
                            } else {
                                p.markedForDeletion = true;
                            }
                        } else if (p.type === 'melee') {
                            // Melee hits everything in range, doesn't delete immediately
                        } else {
                            // Standard bullet
                            p.markedForDeletion = true;
                            hit = true;
                            break;
                        }
                    }
                }
            }
            
            Game.projectiles = Game.projectiles.filter(p => !p.markedForDeletion);
        }

        function updateHUD() {
            document.getElementById('moneyNum').innerText = Game.money;
            document.getElementById('waveNum').innerText = Game.wave;
            
            const hpPct = Math.max(0, (player.hp / player.maxHp) * 100);
            document.getElementById('hpBar').style.width = hpPct + "%";

            // Update Shop Costs
            document.getElementById('costDamage').innerText = COSTS.damage;
            document.getElementById('costSpeed').innerText = COSTS.speed;
            document.getElementById('costHealth').innerText = COSTS.health;
            document.getElementById('costFire').innerText = COSTS.firerate;
        }

        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.innerText = text;
            notif.style.opacity = 1;
            setTimeout(() => notif.style.opacity = 0, 2000);
        }

        /**
         * SHOP LOGIC
         */
        function openShop() {
            Game.state = 'SHOP';
            document.getElementById('shopMenu').style.display = 'flex';
            document.getElementById('nextWaveNum').innerText = Game.wave + 1;
            updateHUD();

            // Auto Start Timer
            let timeLeft = 5;
            const timerDiv = document.getElementById('autoStartTimer');
            timerDiv.innerText = `Pr√≥ximo turno em: ${timeLeft}s`;
            
            if(Game.autoStartInterval) clearInterval(Game.autoStartInterval);
            
            Game.autoStartInterval = setInterval(() => {
                timeLeft--;
                timerDiv.innerText = `Pr√≥ximo turno em: ${timeLeft}s`;
                if(timeLeft <= 0) {
                    nextWave();
                }
            }, 1000);
        }

        function nextWave() {
            if(Game.autoStartInterval) clearInterval(Game.autoStartInterval);
            Game.wave++;
            document.getElementById('shopMenu').style.display = 'none';
            Game.state = 'PLAY';
            player.x = width/2;
            player.y = height/2;
            updateHUD();
            startWave();
        }

        function buyUpgrade(type) {
            if (Game.money >= COSTS[type]) {
                Game.money -= COSTS[type];
                
                if (type === 'damage') {
                    player.dmgMult *= MULTIPLIERS.damage;
                    COSTS.damage = Math.floor(COSTS.damage * 1.3);
                } else if (type === 'speed') {
                    player.speedMult *= MULTIPLIERS.speed;
                    COSTS.speed = Math.floor(COSTS.speed * 1.3);
                } else if (type === 'firerate') {
                    player.fireRateMult *= MULTIPLIERS.firerate;
                    COSTS.firerate = Math.floor(COSTS.firerate * 1.3);
                } else if (type === 'health') {
                    player.hp = Math.min(player.hp + 50, player.maxHp);
                    COSTS.health = Math.floor(COSTS.health * 1.1);
                }
                
                updateHUD();
            } else {
                // Feedback for no money (shake cost)
                const id = 'cost' + type.charAt(0).toUpperCase() + type.slice(1);
                const el = document.getElementById(id);
                el.style.color = 'red';
                setTimeout(() => el.style.color = '#ffd700', 200);
            }
        }

        /**
         * MAIN LOOP
         */
        function loop() {
            requestAnimationFrame(loop);
            
            // Clear Screen
            ctx.fillStyle = 'rgba(5, 5, 16, 0.4)'; // Trails effect
            ctx.fillRect(0, 0, width, height);

            if (Game.cameraShake > 0) {
                ctx.save();
                const dx = (Math.random() - 0.5) * Game.cameraShake;
                const dy = (Math.random() - 0.5) * Game.cameraShake;
                ctx.translate(dx, dy);
                Game.cameraShake *= 0.9;
                if(Game.cameraShake < 0.5) Game.cameraShake = 0;
            }

            // Draw Grid Background
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
            for(let y=0; y<height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
            ctx.stroke();

            if (Game.state === 'PLAY') {
                player.update();
                player.draw();

                // Logic
                Game.enemies.forEach(e => e.update());
                Game.projectiles.forEach(p => p.update());
                checkCollisions();

                // Draw Entities
                Game.enemies.forEach(e => e.draw());
                Game.projectiles.forEach(p => p.draw());

                // Particles & Text
                Game.particles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    if (p.life <= 0) Game.particles.splice(index, 1);
                });
                Game.texts.forEach((t, index) => {
                    t.update();
                    t.draw();
                    if (t.life <= 0) Game.texts.splice(index, 1);
                });

                // Check Wave Clear
                if (Game.enemies.length === 0) {
                    // Slight delay before shop
                    // But we check only if we are truly in play state and no pending spawns (simplified here)
                    // We assume spawning logic handles the "total count"
                    // For this simple engine, we check if all dead and verify logic elsewhere (handled by spawn count)
                    // Let's assume spawner finished and array empty:
                     // (The interval check logic inside startWave handles spawning)
                     // We need a flag "isSpawning"
                }
                
                // End Wave Check (Hack for simple logic: if no enemies and time passed)
                // Actually better: startWave spawns fixed number. When array empty:
                // We need to know if we finished spawning.
                // Let's just check length === 0 and assume spawns are fast enough or use a cooldown
                // To prevent immediate win before spawn:
                // We add a 'waveInProgress' flag in a real engine.
                // Here: If enemies 0, wait 1 sec, open shop.
                // (Adding minimal delay logic)
                 if (Game.enemies.length === 0 && !Game.transitioning) {
                     // Check if we are done spawning? 
                     // Simple fix: only trigger if wave > 0 and recently killed last one
                     // For now, let's just trigger shop if enemies are 0, assuming we spawn at start
                     // To prevent instant trigger at start, we ensure enemies spawned first.
                     // The interval adds enemies.
                     
                     // Better logic: Only trigger if we killed at least one enemy this wave or time passed
                 }
            }

            // Simple wave clear check:
            // Since spawner is async, we need to track "enemiesToSpawn".
            // Since I put spawn logic in setInterval, I can't easily track "finished spawning" without global var.
            // Let's rely on: if enemies.length == 0 AND spawner finished.
            // ...Simplified: Check every frame. If 0 enemies, open shop.
            // FIX: I will add a 'spawning' flag to prevent early win.
            
            // Player Death
            if (player.hp <= 0 && Game.state === 'PLAY') {
                Game.state = 'GAMEOVER';
                document.getElementById('finalWave').innerText = Game.wave;
                document.getElementById('gameOverMenu').style.display = 'flex';
                document.getElementById('gameUI').style.display = 'none';
            }

            if (Game.cameraShake > 0) ctx.restore();
        }

        // Logic to transition to Shop when wave is cleared
        setInterval(() => {
            if (Game.state === 'PLAY' && Game.enemies.length === 0) {
                // Ensure we aren't in the very first millisecond before spawn
                // If spawner is running, we wait.
                // Since spawner uses setInterval (which is ID), we can't easily check "active".
                // Instead, we trust that startWave pushes at least 1 immediately or sets a flag.
                // Let's just add a small "enemiesRemaining" counter in Game object for robustness
            }
        }, 1000);

        // Better Wave Logic override
        const originalStartWave = startWave;
        startWave = function() {
            Game.spawning = true;
            showNotification(`TURNO ${Game.wave}`);
            let total = 5 + Math.floor(Game.wave * 1.5);
            let spawned = 0;
            
            // Add Boss logic
            let hasBoss = Game.wave % 5 === 0;

            const int = setInterval(() => {
                if(Game.state !== 'PLAY') { clearInterval(int); return; }
                
                if (spawned < total) {
                    Game.enemies.push(new Enemy(false));
                    spawned++;
                } else if (hasBoss) {
                    Game.enemies.push(new Enemy(true));
                    showNotification("BOSS!!");
                    hasBoss = false;
                } else {
                    clearInterval(int);
                    Game.spawning = false;
                }
            }, 800);
        }

        // Wave Clear Check
        setInterval(() => {
            if (Game.state === 'PLAY' && !Game.spawning && Game.enemies.length === 0) {
                openShop();
            }
        }, 500);

    </script>
</body>
</html>